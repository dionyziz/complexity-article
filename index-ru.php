<?php
    ob_start();
?>
        <h1 id='gentle'>Доступное введение в анализ сложности алгоритмов.</h1>
        Dionysis "dionyziz" Zindros &lt;<a href='mailto:dionyziz@gmail.com'>dionyziz@gmail.com</a>&gt;<br />
        Перевод: <a href="https://yuga.ego.team" target="_blank">Y. E. T.</a>

        <?= $translations ?>

        <h2 id='intro'>Вступление</h2>
        <p>Многие из современных программистов &mdash; создающих классные и чрезвычайно полезные приложения, которые мы видим в Интернете или используем ежедневно &mdash; не обладают теоретическими знаниями в области информатики. Такие программисты всё же прекрасные созидающие специалисты, и мы благодарны им за то, что они делают.</p>

        <p>Однако теоретические знания имеют прикладное значение и могут быть использованы для решения практических задач. Эта статья предназначена для программистов, владеющих своим искусством, но не имеющих образования в области информатики. В статье будет описан один из самых прагматичных инструментов информатики: анализ сложности алгоритмов. Я работал как в академической среде, так и в сфере построения прикладного программного обеспечения, и обнаружил, что этот инструмент по-настоящему полезен. Так что я надеюсь, что после прочтения этой статьи и вы сможете применять его для улучшения кода. Вы также познакомитесь с такими общепринятыми в информатике терминами, как &laquo;О&dash;большое&raquo;, &laquo;асимптотическое поведение&raquo; и &laquo;анализ наихудшего случая&raquo;.</p>

        <p>Этот текст также предназначен для учеников средних и старших классов, участвующих в <a href='https://ru.wikipedia.org/wiki/Международная_олимпиада_по_информатике'>Международной олимпиаде по информатике</a> или в других подобных соревнованиях. Таким образом, эта статья не требует от вас глубоких математических знаний и предоставит необходимый теоретический материал для дальнейшего изучения алгоритмов. Я сам участвовал в подобных соревнованиях, и поэтому настоятельно рекомендую внимательно прочитать весь вводный материал и попытаться полностью его понять, так как он необходим для дальнейшего изучения алгоритмов и более сложных методов их анализа.</p>

        <p>Я верю, что этот текст будет полезен программистам практикам, не имеющим больших теоретических знаний (некоторые из самых вдохновляющих инженеров программного обеспечения не получали высшего образования). Однако имейте в виду, что статья написана и для учеников, так что время от времени она может несколько напоминать учебник. Также некоторые из тем могут оказаться для вас слишком простыми; к примеру, если вы уже сталкивались с ними. В такой ситуации переходите к следующей теме. Последующие разделы больше углубляются в рассматриваемые вопросы и приобретают теоретическую окраску, так как ученикам, участвующим в соревнованиях, необходимы эти знания. Как бы то ни было, все рассматриваемые здесь темы полезно знать, они доступны для понимания, так что скорее всего достойны вложения вашего времени.</p>

        <p>В этой статье вы найдете ссылки на интересный материал, выходящий за рамки рассматриваемой темы. Если вы профессиональный программист, скорее всего вы уже знакомы с большей частью такого материала. Если вы ученик, участвующий в соревнованиях, изучение дополнительного материала поможет вам познакомиться с другими областями информатики и программирования и, возможно, расширить круг ваших интересов.</p>

        <p>Многие программисты и ученики считают, что анализ сложности алгоритмов труден для понимания. Они боятся его или даже полностью его избегают, думая, что это бесполезная тема. На самом деле, &laquo;O&dash;большое&raquo; и анализ сложности алгоритмов не так трудны для понимания, как это может казаться. Анализ сложности алгоритмов &mdash; это всего лишь способ оценить скорость работы программы или алгоритма, так что это весьма практический инструмент. Давайте начнём с небольшой мотивации.</p>

        <div class='sidefigure'>
            <img src='images/halflife2.jpg' alt='Снимок экрана с персонажем, управляемым искусственным интеллектом игры Half-life 2.' />
            <label><strong>Рисунок 1</strong>: Искусственный интеллект в видеоиграх использует алгоритмы для перемещения персонажей с учётом обхода препятствий.</label>
        </div>

        <h2 id='motivation'>Мотивация</h2>
	
        <p>Мы уже знаем о существовании инструментов, измеряющих скорость работы кода. Эти программы называются <em>профилировщиками</em> (англ. profilers). Профилировщики измеряют длительность работы кода в миллисекундах и помогают выявлять <em>узкие места</em> (англ. bottleneck) в работе кода, для дальнейшей его оптимизации. При всей полезности таких инструментов, профилировщики не имеют отношения к сложности алгоритмов. Анализ сложности алгоритмов был разработан для сравнения алгоритмов на уровне их идей, игнорируя несущественные детали: используемый язык программирования, оборудование, набор команд центрального процессора. Мы хотим сравнить сущность алгоритмов: идеи, каким образом должно быть произведено вычисление. Подсчёт миллисекунд не поможет нам справиться с такой задачей. Вполне вероятно, что плохой алгоритм, написанный на низкоуровневом языке программирования &mdash; к примеру на <a href='https://ru.wikipedia.org/wiki/Язык_ассемблера'>ассемблере</a> &mdash; отработает гораздо быстрее, чем хороший алгоритм, написанный на высокоуровневом языке программирования &mdash; к примеру на <a href='https://www.python.org/'>Python</a> или <a href='https://www.ruby-lang.org/ru/'>Ruby</a>. Итак, настало время дать определение понятию &laquo;более хороший алгоритм&raquo;.</p>

        <p>Так как алгоритмы &mdash; это программы, занятые вычислениями (в отличие от других задач, выполняемых компьютерами: сетевых, ввода и вывода данных пользователем), анализ сложности позволяет нам измерить скорость работы программы. Примеры сугубо <em>вычислительных</em> операций включают в себя операции с числами, представленными в <a href='https://ru.wikipedia.org/wiki/Число_с_плавающей_запятой'>форме с плавающей запятой</a> (такие как сложение и умножение); поиск по <a href="https://ru.wikipedia.org/wiki/Резидентная_база_данных">резидентной базе данных</a> (англ. in-memory database); нахождение самого короткого пути для персонажа, управляемого искусственным интеллектом (<strong>Рисунок 1</strong>); или поиск в тексте с использованием <a href='https://ru.wikibooks.org/wiki/Регулярные_выражения'>регулярных выражений</a>. Очевидно, что вычислительные задачи встречаются повсеместно в компьютерных программах.</p>

        <p>Анализ сложности также позволяет описать, как алгоритм ведёт себя при увеличении размера входных данных. Как поведёт себя алгоритм, получив другое количество входных данных? Если наш алгоритм отрабатывает за 1 секунду, получив 1000 единиц входных данных, то как он поведёт себя, получив в два раза больше данных? Будет ли он работать с той же скоростью или в два раза медленнее, или в четыре раза медленнее? Анализ сложности позволяет предсказывать поведение алгоритма, что важно для прикладного программирования. Предположим, мы написали алгоритм для веб-приложения, хорошо работающий с данными 1000 пользователей, и измерили как быстро он справляется со своей задачей. Тогда анализ сложности алгоритма позволит нам оценить насколько быстро он будет работать, получив данные 2000 пользователей. Для соревнований по информатике, анализ сложности даёт понимание, сколько времени понадобится нашему коду, чтобы обработать самые большие тестовые данные, используемые для проверки правильности работы нашей программы. Таким образом, если мы измерим скорость работы программы с малым количеством входных данных, тогда мы сможем оценить, какова будет скорость её работы с б<strong>о</strong>льшим количеством данных. Начнём с простого примера: нахождение самого большого элемента в массиве данных.</p>

        <h2>Подсчёт инструкций</h2>
	
        <p>В этой статье примеры кода будут написаны на разных языках программирования. Не унывайте, если вы не знакомы с какими-либо из них. Все примеры будут простыми, без использования эзотерических возможностей языков, так что человек, знакомый с программированием, сможет понять все примеры без проблем. Если вы ученик, участвующий в соревнованиях, вы вероятнее всего знакомы с <a href='http://cppstudio.com'>C++</a>, так что примеры и для вас должны быть понятны. Ученикам я рекомендую попрактиковаться с примерами, написав их на C++.</p>

        <p>Мы можем найти наибольший элемент массива используя показанный ниже фрагмент <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript">Javascript</a> кода. Пусть нам дан массив данных <var>A</var> с размером <var>n</var> >= 1. Тогда:</p>

        <pre name='code' class='brush: js; gutter: false; toolbar: false'>
            var M = A[ 0 ];

            for ( var i = 0; i &lt; n; ++i ) {
                if ( A[ i ] &gt;= M ) {
                    M = A[ i ];
                }
            }
        </pre>
	
        <p>Сначала мы подсчитаем количество <em>базовых команд</em> в этом фрагменте кода. Мы проведём такой подсчёт только один раз. Необходимость в нём отпадёт по мере разбора теории, так что наберитесь немного терпения. Во время анализа этого фрагмента кода мы хотим разбить его на простые команды: те, которые могут быть выполнены процессором напрямую (или близко к этому). Предположим, что наш процессор может выполнять такие операции как одну команду:</p>

        <ul>
            <li>Присвоить значение переменной.</li>
            <li>Найти значение заданного элемента в массиве.</li>
            <li>Сравнить два значения.</li>
            <li>Увеличить значение на единицу (инкремент).</li>
            <li>Произвести базовые арифметические действия (сложение, вычитание).</li>
        </ul>

        <p>Мы предположим, что <a href="https://ru.wikipedia.org/wiki/Ветвление_(программирование)">ветвление</a> (выбор между частями кода в теле <code>if</code> или <code>else</code>) происходит мгновенно, и не будем подсчитывать эти команды. Рассмотрим первую строку кода, показанного выше:</p>

        <pre class='brush: jscript; gutter: false; toolbar: false;'>
            var M = A[ 0 ];
        </pre>

        <p>Эта строка содержит две команды: одна находит элемент массива <var>A[ 0 ]</var>, другая присваивает найденную величину переменной <var>M</var>. Алгоритм всегда выполняет эти две команды, независимо от значения <var>n</var>. Цикл <code>for</code> тоже выполняется всегда и даёт нам ещё две команды: присваивания и сравнения.</p>

        <pre class='brush: jscript; gutter: false; toolbar: false;'>
            i = 0;
            i &lt; n;
        </pre>

        <p>Они отработают до первой итерации цикла <code>for</code>. После каждой итерации цикла <code>for</code> отработают ещё две команды: инкремента <var>i</var> и сравнения (для проверки, остаёмся ли мы в цикле):</p>

        <pre class='brush: jscript; gutter: false; toolbar: false;'>
            ++i;
            i &lt; n;
        </pre>
	
        <p>Так что (если мы проигнорируем тело цикла) количество команд выполняемых этим алгоритмом равно 4 + 2n. А именно, 4 команды в начале цикла <code>for</code> и 2 команды в завершении каждой итерации (всего осуществляется <var>n</var> итераций). Теперь мы можем определить математическую функцию f( n ), которая соотносит n с количеством команд, выполняемых алгоритмом. При пустом теле цикла <code>for</code>, f( n ) = 4 + 2n.</p>

        <h2 id='worst'>Анализ наихудшего случая</h2>

        <p>А теперь посмотрим на тело цикла <code>for</code>. Здесь всегда осуществляются поиск в массиве и операция сравнения:</p>

        <pre class='brush: jscript; gutter: false; toolbar: false;'>
            if ( A[ i ] &gt;= M ) { ...
        </pre>

        <p>То есть в теле цикла выполняются две команды. Однако выполнение или невыполнение команд в теле <code>if</code> зависит от значений элементов массива. Если <code>A[ i ] &gt;= M</code>, тогда отработают ещё две команды: поиска в массиве и присваивания:</p>
	
        <pre class='brush: jscript; gutter: false; toolbar: false;'>
            M = A[ i ]
        </pre>
	
        <p>Но теперь мы больше не можем легко определить f( n ), потому что количество команд зависит не только от <var>n</var>, но и от значений вводимых данных. Например, при <code>A = [ 1, 2, 3, 4 ]</code>, алгоритму понадобится выполнить больше команд, чем при <code>A = [ 4, 3, 2, 1 ]</code>. При анализе алгоритмов часто рассматривается наихудший сценарий. Какие входные данные самые неблагоприятные для нашего алгоритма? В каком случае нашему алгоритму понадобится выполнить максимальное количество операций? Для рассматриваемого примера самый плохой вариант &mdash; это получить массив, отсортированный по возрастанию, например: <code>A = [ 1, 2, 3, 4 ]</code>. В таком случае с каждой новой итерацией значение i-го элемента массива будет присвоено <var>M</var>, а это максимальное количество выполняемых команд. Для таких случаев у теоретиков есть затейливое название: <em>анализ наихудшего случая</em>; а ведь это всего лишь рассмотрение самого неудачного варианта. Итак, при наихудшем случае в теле цикла <code>for</code> отработает 4 команды. Итого, f( n ) = 4 + 2n + 4n = 6n + 4. Функция f при заданной проблеме с размером n даёт нам количество команд, исполняемых в наихудшем случае.</p>

        <h2 id='asymptotic'>Асимптотическое поведение</h2>
	
        <p>Полученная выше функция даёт нам довольно ясное представление о скорости работы алгоритма. Однако, как я и обещал, нам не понадобится каждый раз заниматься трудоёмким подсчётом количества команд в программе. К тому же количество реальных команд, выполняемых процессором, зависит от компилятора нашего языка программирования и от типа самого процессора. Как мы уже говорили, мы проигнорируем эту разницу. Сейчас мы пропустим нашу функцию &laquo;f&raquo; через &laquo;фильтр&raquo;, который поможет нам избавиться от несущественных деталей, игнорируемых во время анализа.</p>

        <p>Функция <code>f( n ) = 6n + 4</code> состоит из двух членов: 6n и 4. При анализе сложности нас интересует, что происходит с функцией подсчёта команд при увеличении количества входных данных <var>n</var>. Этот подход хорошо соответствует анализу поведения при наихудшем случае: нам интересно узнать, как алгоритм поведёт себя в &laquo;плохих&raquo; условиях (при необходимости обработать тяжёлую задачу). Заметьте, что это очень удобно при сравнении алгоритмов между собой. Если один алгоритм &laquo;побеждает&raquo; другой при большом количестве входных данных, тогда наиболее вероятно, что более быстрый алгоритм останется таковым и при меньшем количестве входных данных. <strong>Поэтому мы пренебрежём теми членами функции, которые растут медленно, и оставим те, которые растут очень быстро при увеличении n</strong>. Явно, что 4 останется равным 4 при любом значении <var>n</var>. При этом 6n будет становиться больше и больше с увеличением значения <var>n</var>, так что именно 6n будет иметь всё большее и большее значение с увеличением входных данных. Следовательно, мы можем пренебречь значением 4 и записать нашу функцию в такой форме: <code>f( n ) = 6n</code>.</p>

        <p>И это здравый подход, ведь 4 &mdash; всего лишь &laquo;константа инициализации&raquo;. Разным языкам программирования может понадобиться разное количество времени для инициализации. Например, языку Java требуется значительное количество времени для запуска <a href="https://ru.wikipedia.org/wiki/Java_Virtual_Machine">виртуальной машины</a>. А так как мы игнорируем различия между языками программирования, то разумно будет пренебречь и константой 4.</p>

        <p>Ещё один элемент, которым можно пренебречь &mdash; это постоянный множитель 6. Таким образом, нашу функцию можно записать в таком виде: <code>f( n) = n</code>. Как видите, мы очень сильно упростили функцию подсчёта команд. И это снова выглядит как разумный подход, принимая во внимание, что разные языки программирования компилируются по-разному. Например, язык C, выполняя инструкцию <code>A[ i ]</code>, не удостоверяется, что значение <var>i</var> находится в диапазоне размера массива. В то же время <a href='https://ru.wikipedia.org/wiki/Паскаль_(язык_программирования)'>Паскаль</a> делает такую проверку. Другими словами, последующий фрагмент кода на языке Паскаль:</p>

        <pre class='brush: delphi; gutter: false; toolbar: false;'>
            M := A[ i ]
        </pre>

        <p>эквивалентен такому коду на языке C:</p>

        <pre class='brush: c; gutter: false; toolbar: false;'>
            if ( i &gt;= 0 &amp;&amp; i &lt; n ) {
                M = A[ i ];
            }
        </pre>

        <p>Так что во время подсчёта команд приемлемо ожидать разные множители от разных языков программирования. В нашем примере для языка Паскаль используется самый примитивный компилятор, без каких-либо оптимизаций. В таком случае Паскалю необходимо 3 команды для каждого запроса к массиву данных; вместо лишь 1 команды, выполняемой языком C. Опуская соответствующий множитель, мы поступаем согласно уже принятому нами подходу игнорирования разницы между языками программирования и анализа самой сущности алгоритмов.</p>

        <p>Описанный выше фильтр &laquo;пренебрежения множителями и константами&raquo; имеет название: <em>асимптотическое поведение</em>. Так, асимптотическое поведение функции <code>f( n ) = 2n + 8</code> описывается функцией <code>f( n ) = n</code>. Говоря математическим языком, нам интересен предел функции f при <var>n</var>, стремящемся к бесконечности. (Если вам не понятен смысл этой фразы, не беспокойтесь: достаточно, что вы ознакомились с этой формулировкой. Примечание: при строгом математическом подходе мы не смогли бы пренебречь константами; но для задач в сфере информатики мы ими пренебрегаем по причинам, описанным выше). А теперь проработаем пару примеров, чтобы привыкнуть к уже описанным концепциям.</p>

        <div class='right sidefigure'>
            <img src='images/cubic-vs-linear.png' alt='Кубическая функция имеет большие значения, чем линейная функция, после n = 45' />
            <label><strong>Рисунок 2</strong>: После n = 45, значения функции n<sup>3</sup> (синий график) навсегда становятся больше значений функции 1999n (красный график).</label>
        </div>

        <p>Найдем асимптотическое поведение следующих функций:</p>

        <ol>
            <li><p>f( n ) = 5n + 12 даёт f( n ) = n.</p>
                <p>Следуя ходу мысли, изложенному выше.</p></li>

            <li><p>f( n ) = 109 даёт f( n ) = 1.</p>
                <p>Мы пренебрегаем множителем 109 * 1, но должны оставить 1 для обозначения, что функция обладает не нулевым значением.</p></li>

            <li><p>f( n ) = n<sup>2</sup> + 3n + 112 даёт f( n ) = n<sup>2</sup></p>
                <p>n<sup>2</sup> растёт быстрее, чем 3n, при достаточно большом значении <var>n</var>.</p></li>

            <li><p>f( n ) = n<sup>3</sup> + 1999n + 1337 даёт f( n ) = n<sup>3</sup></p>
                <p>Множитель 1999 довольно велик, но мы всё же можем найти достаточно большое значение <var>n</var>, такое, что n<sup>3</sup> будет больше, чем 1999n. А так как мы заинтересованы в поведении при очень больших значениях <var>n</var>, то мы оставляем только n<sup>3</sup> (смотрите <strong>Рисунок 2</strong>).</p></li>

            <li><p>f( n ) = n + <img alt='sqrt( n )' src='images/sqrtn.png' /> даёт f( n ) = n</p>
                <p>Из-за того, что n растёт быстрее чем <img alt='sqrt( n )' src='images/sqrtn.png' /> по мере увеличения <var>n</var>.</p></li>
        </ol>

        <p>Попробуйте найти асимптотическое поведение следующих функций самостоятельно:</p>
        <div class='exercise'>
            <h3>Упражнение 1</h3>
            <ol>
                <li>f( n ) = n<sup>6</sup> + 3n</li>
                <li>f( n ) = 2<sup>n</sup> + 12</li>
                <li>f( n ) = 3<sup>n</sup> + 2<sup>n</sup></li>
                <li>f( n ) = n<sup>n</sup> + n</li>
            </ol>
            <p>(Запишите ваши результаты; решения даны ниже.)</p>

            <p>Если у вас возникли проблемы с какой-либо из функций, подставьте в неё большое значение <var>n</var> и сравните, какой из членов становится больше. Довольно-таки просто, ага?</p>
        </div>

        <h2 id='complexity'>Сложность</h2>

        <p>Так как мы можем пренебречь всеми декоративными константами, то довольно легко определить асимптотическое поведение функции подсчёта команд. На самом деле, асимптотическое поведение любой программы без циклов будет f( n ) = 1, так как количество команд, выполняемых такой программой, всегда равно какой-то константе (это не касается случая рекурсии, рассматриваемого ниже). Асимптотическое поведение любой программы с одним циклом, проходящем от 1 до <var>n</var>, будет f( n ) = n, так как такая программа будет вызывать какое-то постоянное количество команд до начала цикла, после завершения цикла и внутри цикла (команды внутри цикла всего будут вызываться <var>n</var> раз).</p>

        <p>Такой подход должен быть на порядок проще, чем громоздкий подсчёт всех команд программы. Так что давайте взглянем на пару примеров, чтобы привыкнуть к нему. Следующая программа, написанная на языке <a href='https://www.php.net/manual/ru/getting-started.php'>PHP</a>, проверяет, находится ли заданное значение в массиве <var>A</var> с размером <var>n</var>:</p>

        <pre class='brush: php; gutter: false; toolbar: false;'>
            &lt;?php
                $exists = false;
                for ( $i = 0; $i &lt; n; ++$i ) {
                    if ( $A[ $i ] == $value ) {
                        $exists = true;
                        break;
                    }
                }
            ?&gt;
        </pre>

        <p>Такой метод поиска значения в массиве данных называется <em>линейным поиском</em>. Это подходящее название, так как асимптотическое поведение этой программы описывается функцией f( n ) = n (мы дадим точное определение &laquo;линейности&raquo; в следующем разделе). Обратите внимание на инструкцию &laquo;break&raquo;, которая может вызвать более раннее завершение работы программы (возможно, сразу же на первом шаге цикла). Вспомните, что нас интересует только самый плохой сценарий. Для данной программы &mdash; это отсутствие искомого элемента в массиве <var>A</var>. Так что мы всё ещё имеем f( n ) = n.</p>

        <div class='exercise'>
            <h3>Упражнение 2</h3>

            <p>Используя данную выше программу на языке PHP, подсчитайте количество команд, вызываемых этой программой в наихудшем случае, и выведите функцию подсчёта команд f( n ), как мы это уже делали на примере Javascript программы. Затем проверьте, что асимптотически мы получаем сложность, описываемую функцией <code>f( n ) = n</code>.</p>
        </div>

        <p>Взгляните на программу, написанную на языке Python. Эта программа складывает значения двух элементов массива и присваивает результат сложения новой переменной:</p>

        <pre class='brush: python; gutter: false; toolbar: false;'>
            v = a[ 0 ] + a[ 1 ]
        </pre>

        <p>Эта программа содержит постоянное количество команд, так что f( n ) = 1.</p>

        <p>Следующая программа на языке C++ проверяет, содержит ли вектор (причудливый массив) <var>A</var> с размером <var>n</var> два одинаковых значения:</p>

        <pre class='brush: cpp; gutter: false; toolbar: false;'>
            bool duplicate = false;
            for ( int i = 0; i &lt; n; ++i ) {
                for ( int j = 0; j &lt; n; ++j ) {
                    if ( i != j &amp;&amp; A[ i ] == A[ j ] ) {
                        duplicate = true;
                        break;
                    }
                }
                if ( duplicate ) {
                    break;
                }
            }
        </pre>

        <p>Эта программа содержит вложенные циклы. В таком случае асимптотическое поведение описывается функцией f( n ) = n<sup>2</sup>.</p>

        <div class='highlight'>
            <p class='thumb'><strong>Подсказка</strong>: Простые программы могут быть проанализированы путём подсчёта циклов. Единичный цикл с n шагами приводит к сложности f( n ) = n. Дополнительный вложенный цикл приводит к сложности f( n ) = n<sup>2</sup>. Цикл внутри цикла внутри цикла имеет сложность f( n ) = n<sup>3</sup>.</p>
        </div>

        <p>Если программа вызывает функцию в теле цикла, и если нам известно количество команд, исполняемых этой функцией, тогда несложно подсчитать количество команд, выполняемых всей программой. Действительно, взгляните на такой пример на языке C:</p>

        <pre class='brush: c; gutter: false; toolbar: false;'>
            int i;
            for ( i = 0; i &lt; n; ++i ) {
                f( n );
            }
        </pre>

        <p>Если нам известно, что <code>f( n )</code> выполняет <var>n</var> команд, значит мы знаем, что количество команд, выполняемых всей программой, асимптотически равно n<sup>2</sup>, так как функция <code>f( n )</code> будет вызвана точно <var>n</var> раз.</p>

        <div class='highlight'>
            <p class='thumb'><strong>Подсказка</strong>: Если нам дана последовательность циклов for, то самый медленный из них определяет асимптотическое поведение всей программы. Два вложенных цикла, за которыми следует одиночный цикл, асимптотически равны просто двум вложенным циклам, потому что вложенные циклы <em>доминируют</em> над одиночными.</p>
        </div>

        <p>Теперь перейдём к причудливому способу записи, используемому теоретиками. Когда мы выводим асимптотическое поведение, мы можем сказать, что наша программа &mdash; это Θ( f( n ) ). Например, программы выше &mdash; это, соответственно, Θ( 1 ), Θ( n<sup>2</sup> ) и Θ( n<sup>2</sup> ). Θ( n ) произносится как &laquo;тета от эн&raquo;. Иногда мы говорим, что f( n ), изначальная функция подсчёта команд программы, включающая в себя константы, &mdash; это Θ( что-то ). Например, можно сказать, что функция f( n ) = 2n &mdash; это Θ( n ). Ещё один вариант записи: 2n ∈ Θ( n ), произносится как "два эн есть тета от эн". Не смущайтесь, ведь всё, что эта форма записи говорит: мы подсчитали количество команд, выполняемых программой, и оно равно 2n; значит асимптотическое поведение алгоритма можно описать как n (опустив константу 2). Следующие математические выражения используют новый способ записи:</p>
        <ol>
            <li>n<sup>6</sup> + 3n ∈ Θ( n<sup>6</sup> )</li>
            <li>2<sup>n</sup> + 12 ∈ Θ( 2<sup>n</sup> )</li>
            <li>3<sup>n</sup> + 2<sup>n</sup> ∈ Θ( 3<sup>n</sup> )</li>
            <li>n<sup>n</sup> + n ∈ Θ( n<sup>n</sup> )</li>
        </ol>

        <p>Кстати, это и есть ответы к упражнению 1.</p>

        <p><strong>Мы называем эту функцию &mdash; я имею в виду ту функцию, которую мы разместили Θ( здесь ) &mdash; <em>временнОй сложностью</em> или просто <em>сложностью</em> алгоритма.</strong> Так, алгоритм с Θ( n ) имеет сложность n. У нас также есть специальные названия для Θ( 1 ), Θ( n ), Θ( n<sup>2</sup> ) и Θ( log( n ) ), потому что это очень часто встречающиеся классы сложности. Алгоритм с Θ( 1 ) называется <em>алгоритмом константного времени</em>, Θ( n ) &mdash; <em>линейным алгоритмом</em>, Θ( n<sup>2</sup> ) &mdash; <em>квадратичным</em>, Θ( log( n ) ) &mdash; <em>логарифмическим</em> (не беспокойтесь, если вы не знакомы с последним термином: логарифмы будут рассмотрены чуть ниже).</p>

        <div class='highlight'>
            <p class='thumb'><strong>Подсказка</strong>: Чем больше Θ, тем медленнее работает программа.</p>
        </div>

        <div class='right sidefigure'>
            <img src='images/hidden-surface.jpg' alt='Пример скрытой поверхности в видео игре' />
            <label><strong>Рисунок 3</strong>: Игрок, расположенный в зоне, отмеченной жёлтой точкой, не будет видеть затемнённой зоны. Одним из способов определения зоны видимости является разбиение мира на маленькие фрагменты и дальнейшая сортировка этих фрагментов.</label>
        </div>

        <h2 id='big-o'>&laquo;O&dash;большое&raquo;</h2>

        <p>На самом деле иногда нелегко определить поведение алгоритма, используя данный выше подход. Особенно это касается более сложных примеров. Как бы то ни было, всегда возможно оценить, в каких рамках ведёт себя алгоритм. Это облегчает нам жизнь, так как освобождает от необходимости определять точную скорость работы алгоритма. Всё, что нам необходимо сделать &mdash; это определить границы поведения алгоритма. Этот подход доступно объясняется на следующем примере.</p>

        <p>Для обучения алгоритмам обычно используется задача <em>сортировки</em>. В этой задаче даётся массив <var>A</var> с размером <var>n</var> (звучит знакомо?), и нас просят написать программу, которая упорядочивает элементы массива. Это интересная задача: она имеет практическое применение в реальных системах. Например, менеджер файлов должен отсортировать файлы по наименованию, для упрощения навигации пользователя. Или другой пример: видеоигре необходимо отсортировать 3D объекты мира на основании их расположения относительно игрока, для определения какие из объектов видны, а какие нет (<a href='https://en.wikipedia.org/wiki/Hidden_surface_determination'>расчёт области видимости</a>, смотрите <strong>Рисунок 3</strong>). Самые близкие к игроку объекты будут видны, а более удалённые могут быть скрыты объектами между ними. Сортировка становится ещё более интересной из-за наличия различающихся по эффективности алгоритмов сортировки. И, наконец, это довольно доступная для объяснения и понимания задача. Так что и мы сейчас напишем код сортировки массива.</p>

        <p>Далее показан неэффективный способ реализации сортировки массива, написанный на языке Ruby. (Конечно, Ruby предоставляет встроенные функции для сортировки массивов, которые и следует использовать в большинстве случаев. Встроенные функции работают быстрее, чем показанная ниже программа, предложенная в сугубо иллюстрационных целях).</p>

        <div class='leftofimage'>
            <pre class='brush: ruby; gutter: false; toolbar: false;'>
                b = []
                n.times do
                    m = a[ 0 ]
                    mi = 0
                    a.each_with_index do |element, i|
                        if element &lt; m
                            m = element
                            mi = i
                        end
                    end
                    a.delete_at( mi )
                    b &lt;&lt; m
                end
            </pre>
        </div>

        <p>Такой метод называется <a href='https://ru.wikipedia.org/wiki/Сортировка_выбором'>сортировкой выбором</a> (англ. selection sort). Сортировка выбором находит наименьшее значение массива (мы обозначили массив как <var>a</var>, минимальное значение <var>m</var>, индекс этого значения <var>mi</var>), добавляет найденное значение в конец массива <var>b</var> и удаляет это значение из заданного массива <var>a</var>. Затем алгоритм снова находит минимальное значение среди оставшихся элементов массива <var>a</var>, добавляет его в конец массива <var>b</var> (теперь массив <var>b</var> содержит два отсортированных элемента) и удаляет из массива <var>a</var>. Перечисленные шаги повторяются до тех пор, пока изначально заданный массив не станет пустым, а все его элементы окажутся перенесёнными в новый, отсортированный, массив. Этот пример  содержит вложенные циклы. Внешний цикл отрабатывает <var>n</var> раз, а внутренний массив отрабатывает один раз для каждого элемента массива <var>a</var>. Изначально массив <var>a</var> содержит <var>n</var> элементов, однако мы удаляем из него один элемент на каждом шаге внешнего цикла. Так что внутренний цикл отрабатывает <var>n</var> раз во время первого шага внешнего цикла, затем <code>n - 1</code> раз, затем <code>n - 2</code> раз и так далее, до последнего шага внешнего цикла, на котором внутренний цикл отработает лишь один раз.</p>

        <p>Оценить сложность этой программы немного труднее, так как нам надо подсчитать сумму 1 + 2 + ... + (n - 1) + n. Но мы точно можем найти &laquo;верхнюю границу&raquo; для этой программы. Ведь мы можем изменить нашу программу (вы можете проделать эту операцию в уме, без написания кода) таким образом, чтобы она стала <strong>хуже</strong>, чем она есть на самом деле, и затем найти сложность такой выведенной программы. Если мы найдём сложность выведенной программы, то сложность оригинальной программы будет такой же или даже меньшей. То есть, если окажется, что выведенная программа довольно эффективна (эта эффективность по определению хуже, чем у нашей изначальной программы), то мы сможем сделать вывод, что оригинальная программа тоже имеет хорошую эффективность. По крайней мере, не меньше (или даже больше), чем у выведенной &mdash; ухудшенной  &mdash; программы.</p>

        <p>А теперь подумаем о способе отредактировать программу из примера так, чтобы упростить оценку её сложности. При этом удерживайте мысль о том, что мы можем изменять её лишь в сторону ухудшения, то есть сделать так, чтобы она выполняла ещё больше команд (чтобы оценка сложности правильно соотносилась с изначальной программой). Очевидно, что мы можем изменить количество шагов, выполняемых внутренним циклом программы так, чтобы их всегда было точно <var>n</var>, вместо уменьшающегося количества шагов. Некоторые из этих повторений будут бесполезными для сортировки, но упростят нам анализ сложности алгоритма. Если мы сделаем это простое изменение, тогда новый, только что сконструированный, алгоритм будет оцениваться как Θ( n<sup>2</sup> ), потому что он будет состоять из двух вложенных циклов, каждый из которых повторяется <var>n</var> раз. В такой ситуации мы говорим, что оригинальный алгоритм имеет сложность O( n<sup>2</sup> ). O( n<sup>2</sup> ) произносится как &laquo;большое о от эн в квадрате&raquo;. Это означает, что наша программа асимптотически не хуже, чем n<sup>2</sup> (она может быть лучше или равняться n<sup>2</sup>). Между прочим, если наша программа в действительности имеет сложность Θ( n<sup>2</sup> ), то это соответствует и O( n<sup>2</sup> ). Чтобы помочь вам это осмыслить, представьте, как вы изменяете изначальную программу совсем немного, но всё же ухудшаете её производительность, например добавив несущественную команду в начало программы. Таким способом вы измените функцию подсчёта команд на константу, игнорируемую при определении асимптотического поведения. Отсюда следует, что программа Θ( n<sup>2</sup> ) также является и O( n<sup>2</sup> ).</p>

        <p>Но вот программа со сложностью O( n<sup>2</sup> ) может не иметь Θ( n<sup>2</sup> ). Например, любая программа с Θ( n ) &mdash; это также O( n<sup>2</sup> ), вдобавок к O( n ). Представим, что программа Θ( n ) &mdash; это простой цикл <code>for</code>, повторяющийся <var>n</var> раз. Тогда мы можем ухудшить её, обернув во второй цикл <code>for</code>, тоже повторяющийся <var>n</var> раз, и получив в результате программу с f( n ) = n<sup>2</sup>. Обобщим: любая программа со сложностью Θ( <var>a</var> ) также имеет и сложность O( <var>b</var> ), если <var>b</var> растёт быстрее, чем <var>a</var>. Заметьте, что изменения, внесённые в программу, не должны привести к правильно работающей программе или программе, аналогичной изначальной. Ей только необходимо выполнять больше команд, чем выполняется оригинальной версией программы. Изменённую программу мы используем сугубо для подсчёта команд, а не для решения изначальной задачи.</p>

        <p>Итак, безопаснее будет сказать, что наша программа имеет сложность O( n<sup>2</sup> ): мы проанализировали алгоритм и нашли, что он никогда не работает хуже, чем n<sup>2</sup>. Такая формулировка даёт нам хорошую оценку скорости работы нашей программы. Следующие упражнения даны для привыкания к новой нотации.</p>

        <div class='exercise'>
            <h3>Упражнение 3</h3>

            <p>Определите, какие из формулировок верны:</p>
            <ol>
                <li>Алгоритм с Θ( n ) имеет сложность O( n )</li>
                <li>Алгоритм с Θ( n ) имеет сложность O( n<sup>2</sup> )</li>
                <li>Алгоритм с Θ( n<sup>2</sup> ) имеет сложность O( n<sup>3</sup> )</li>
                <li>Алгоритм с Θ( n ) имеет сложность O( 1 )</li>
                <li>Алгоритм с O( 1 ) имеет сложность Θ( 1 )</li>
                <li>Алгоритм с O( n ) имеет сложность Θ( 1 )</li>
            </ol>
        </div>

        <div class='exercise solution'>
            <h3>Решения</h3>

            <ol>
                <li>Это правда, так как наша изначальная программа имеет сложность Θ( n ). Мы можем получить O( n ) даже не меняя программу.</li>
                <li>Так как n<sup>2</sup> хуже, чем n, то и это утверждение верно.</li>
                <li>Так как n<sup>3</sup> хуже, чем n<sup>2</sup>, то это утверждение верно.</li>
                <li>Так как 1 не хуже, чем n, то это неверное утверждение. Если программа асимптотически выполняет <var>n</var> команд (линейное количество), то мы не можем усложнить её и получить всего лишь одну команду, выполняемую асимптотически (константное количество).</li>
                <li>Это верно, так как эти сложности равнозначны.</li>
                <li>Это может быть как верным, так и ложным утверждением. В общем случае оно ложно. Если алгоритм имеет сложность Θ( 1 ), тогда он конечно же имеет сложность O( n ). Но при O( n ), он не обязательно будет иметь сложность Θ( 1 ). Например, алгоритм Θ( n ) имеет сложность O( n ), но не Θ( 1 ).</li>
            </ol>
        </div>

        <div class='exercise'>
            <h3>Упражнение 4</h3>

            <p>Используйте формулу суммы арифметической прогрессии для доказательства, что данная выше программа имеет сложность не только O( n<sup>2</sup> ), но также Θ( n<sup>2</sup> ). Если вы не знаете, что такое арифметическая прогрессия, загляните в <a href='https://ru.wikipedia.org/wiki/Арифметическая_прогрессия'>Википедию</a> &mdash; это легко.</p>
        </div>
	
	<p>Так как &laquo;О&dash;большое&raquo; алгоритма описывает <em>верхнюю границу</em> реальной сложности алгоритма, описываемой Θ, то иногда можно сказать, что Θ описывает <em>точные границы</em> сложности. Если известно, что найденная граница сложности не является точной, то в таких случаях можно использовать нотацию &laquo;o-малое&raquo;. Например, если алгоритм имеет сложность Θ( n ), тогда его точная сложность соответствует n. Следовательно, этот алгоритм имеет сложность и O( n ), и O( n<sup>2</sup> ). Граница O( n ) является точной, но граница O( n<sup>2</sup> ) &mdash; нет. Так что можно написать, что этот алгоритм имеет сложность o( n<sup>2</sup> ) &mdash; произносится &laquo;o малое от эн в квадрате&raquo; &mdash; для иллюстрации того, что эта граница неточная. Обычно лучше знать точные границы алгоритмов, ведь таким образом больше становится известно о поведении алгоритма. Однако точные границы не всегда легко определить.</p>

        <div class='exercise'>
            <h3>Упражнение 5</h3>

            <p>Определите, какие из перечисленных границ точные, а какие нет. Проверьте, все ли границы верны. Используйте &laquo;О&dash;большое&raquo; для иллюстрации неточных границ.</p>

            <ol>
                <li>Алгоритм с Θ( n ) и верхней границей O( n ).</li>
                <li>Алгоритм с Θ( n<sup>2</sup> ) и верхней границей O( n<sup>3</sup> ).</li>
                <li>Алгоритм с Θ( 1 ) и верхней границей O( n ).</li>
                <li>Алгоритм с Θ( n ) и верхней границей O( 1 ).</li>
                <li>Алгоритм с Θ( n ) и верхней границей O( 2n ).</li>
            </ol>
        </div>

        <div class='exercise solution'>
            <h3>Решения</h3>

            <ol>
                <li>В этом случае Θ и O сложности одинаковы, так что это точная граница.</li>
                <li>Здесь мы видим, что O даёт большую сложность, чем Θ, так что эта граница неточная (сложность O( n<sup>2</sup> ) дала бы точную границу). Следовательно, мы можем записать сложность алгоритма как o( n<sup>3</sup> ).</li>
                <li>Снова мы видим, что O даёт большую сложность, чем Θ. Так что это неточная граница (граница O( 1 ) была бы точной). Следовательно, можно обозначить, что граница O( n ) неточная, записав её в виде o( n ).</li>
                <li>Должно быть мы ошиблись при выводе этой границы; она неверна. Для алгоритма с Θ( n ) невозможно, чтобы верхняя граница была O( 1 ), ведь n имеет большую сложность, чем 1. Помните, что &laquo;О&dash;большое&raquo; описывает верхнюю границу.</li>
                <li>Может показаться, что это неточная граница, однако это не так. Эта граница на самом деле точная. Вспомните, что асимптотическое поведение 2n есть n; и что O и Θ описывают асимптотическое поведение. Из этого следует, что O( 2n ) = O( n ), и значит это точная граница, ведь она равна Θ.</li>
            </ol>
        </div>

        <div class='highlight'>
            <p class='thumb'><strong>Подсказка</strong>: Вывести O-сложность легче, чем Θ-сложность.</p>
        </div>

        <p>Возможно, к этому моменту вас уже утомили все эти новые формы записи. Всё же познакомимся с ещё двумя символами и затем перейдём к примерам. Эти символы будет легко понять на базе уже знакомых вам Θ, O и o. Новые символы не будут использоваться в оставшейся части статьи, однако хорошо бы их знать, и сейчас подходящий момент для такого знакомства. В примере выше, мы изменяли программу так, чтобы она работала хуже (добавив команды для замедления её работы), и выводили таким образом &laquo;О&dash;большое&raquo;. &laquo;O&raquo; предоставляет ценную информацию, на базе которой можно доказывать, что наша программа работает достаточно хорошо. Если проделать обратное действие: <strong>улучшить</strong> программу, а затем найти её сложность, то можно использовать форму записи &laquo;Ω&raquo;. Ω описывает сложность таким образом, что мы знаем: наша программа не будет работать лучше этой сложности. Такое знание полезно в тех случаях, когда мы хотим показать, что программа работает медленно или что анализируемый алгоритм не эффективен для решения определённой задачи. Например, алгоритм со сложностью Ω( n<sup>3</sup> ) означает, что этот алгоритм не работает лучше, чем n<sup>3</sup> (он как минимум настолько плох). То есть этот алгоритм может иметь сложность Θ( n<sup>3</sup> ), или Θ( n<sup>4</sup> ), или даже хуже. Итак, Ω даёт нам <em>нижнюю границу</em> сложности алгоритма. Наподобие &laquo;ο-малое&raquo;, можно использовать запись в виде &laquo;ω-малое&raquo; в тех случаях, когда известно, что граница неточная. Например, алгоритм Θ( n<sup>3</sup> ) имеет ο( n<sup>4</sup> ) и ω( n<sup>2</sup> ). Ω( n ) произносится как &laquo;омега большое от эн&raquo;, а ω( n ) произносится как &laquo;омега малое от эн&raquo;.</p>

        <div class='exercise'>
            <h3>Упражнение 6</h3>

            <p>Определите точные и неточные О и Ω границы для следующих Θ сложностей.</p>
            <ol>
                <li>Θ( 1 )</li>
                <li>Θ( <img alt='sqrt( n )' src='images/sqrtn.png' /> )</li>
                <li>Θ( n )</li>
                <li>Θ( n<sup>2</sup> )</li>
                <li>Θ( n<sup>3</sup> )</li>
            </ol>
        </div>

        <div class='exercise solution'>
            <h3>Решения</h3>

            <ol>
                <li>Точными границами являются O( 1 ) и Ω( 1 ). Неточной O-границей может быть O( n ). Вспомните, что O даёт нам верхнюю границу. Так как n имеет большую сложность, чем 1, то эту неточную границу можно также записать в виде o( n ). Неточная Ω граница не существует, так как мы не можем упростить сложность, равную 1.</li>
                <li>Точные границы равны Θ-сложности, так что это, соответственно, O( <img alt='sqrt( n )' src='images/sqrtn.png' /> ) и Ω( <img alt='sqrt( n )' src='images/sqrtn.png' /> ). В роли неточной границы можно использовать O( n ), так как n больше чем <img alt='sqrt( n )' src='images/sqrtn.png' />. Зная, что это неточная верхняя граница, можно использовать форму записи o( n ). Для неточной нижней границы можно использовать Ω( 1 ), что также можно записать в виде ω( 1 ).</li>
                <li>Точными границами являются O( n ) и Ω( n ). Неточными границами могут быть ω( 1 ) и o( n<sup>3</sup> ). Это довольно плохой выбор границ, так как они сильно отличаются от заданной сложности. Однако они соответствуют данным нами определениям, так что могут быть использованы.</li>
                <li>Точными границами являются O( n<sup>2</sup> ) и Ω( n<sup>2</sup> ). В качестве неточных границ можно снова использовать ω( 1 ) и o( n<sup>3</sup> ), как и в предыдущем примере.</li>
                <li>Точными границами являются O( n<sup>3</sup> ) и Ω( n<sup>3</sup> ), соответственно. Неточными границами могут быть ω( <img alt='sqrt( n )' src='images/sqrtn.png' /> n<sup>2</sup> ) и o( <img alt='sqrt( n )' src='images/sqrtn.png' /> n<sup>3</sup> ). Хотя эти границы неточные, всё же они лучше тех, что были даны выше.</li>
            </ol>
        </div>

        <p>Причина использования O и Ω вместо Θ &mdash; хотя O и Ω тоже могут определять точные границы &mdash; заключается в том, что не всегда известно, является ли найденная граница точной (вероятно в ситуации, когда мы просто не хотим дотошно анализировать алгоритм).</p>

        <p>Если вы не запомнили все упомянутые символы и их точное использование, не беспокойтесь. Вы всегда можете вернуться к этой статье и уточнить их данные. Самыми важными символами являются O и Θ.</p>

        <p>Также заметьте, что хотя Ω определяет поведение нижней границы функции (т.е. функция была улучшена посредством урезания количества выполняемых команд), мы всё ещё ссылаемся на анализ &laquo;наихудшего случая&raquo;. Так происходит потому, что программе даётся самый плохой вариант из возможных входящих данных; её поведение анализируется исходя из этого предположения.</p>

        <p>Следующая таблица показывает только что представленные символы и соответствующие им обычные математические символы, используемые для сравнения чисел. Буквы греческого алфавита используются вместо более привычных символов для указания, что мы занимаемся сравнением асимптотического поведения, а не чисел.</p>

        <div class='figure'>
            <table>
                <thead>
                    <tr>
                        <th>Асимптотическое сравнение</th>
                        <th>Численное сравнение</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Алгоритм с <strong>o</strong>( что-то )</td>
                        <td>Число <strong>&lt;</strong> что-то</td>
                    </tr>
                    <tr>
                        <td>Алгоритм с <strong>O</strong>( что-то )</td>
                        <td>Число <strong>≤</strong> что-то</td>
                    </tr>
                    <tr>
                        <td>Алгоритм с <strong>Θ</strong>( что-то )</td>
                        <td>Число <strong>=</strong> что-то</td>
                    </tr>
                    <tr>
                        <td>Алгоритм с <strong>Ω</strong>( что-то )</td>
                        <td>Число <strong>≥</strong> что-то</td>
                    </tr>
                    <tr>
                        <td>Алгоритм с <strong>ω</strong>( что-то )</td>
                        <td>Число <strong>></strong> что-то</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class='highlight'>
            <p class='thumb'><strong>Подсказка</strong>: Хотя все символы O, o, Ω, ω и Θ очень полезны, &laquo;О&dash;большое&raquo; используется наиболее часто. Его проще определить, чем Θ, и оно более практично, чем Ω.</p>
        </div>

        <div class='right sidefigure'>
            <img src='images/log-vs-linear.png' alt='Даже при маленьком n, логарифмическая функция расположена гораздо ниже функции квадратного корня, которая, в свою очередь, расположена гораздо ниже линейной функции.' />
            <label><strong>Рисунок 4</strong>: Сравнение функций n, <img alt='sqrt( n )' src='images/sqrtn.png' />, и log( n ). Линейная функция n (нарисована зелёным цветом, расположена вверху), растёт гораздо быстрее, чем функция квадратного корня (нарисована красным цветом, расположена посередине), которая в свою очередь растёт гораздо быстрее, чем функция log( n ) (нарисована синим цветом внизу графика). Даже для маленьких значений n, таких как n = 100, разница довольно существенна.</label>
        </div>

        <h2 id='logarithms'>Логарифмы</h2>

        <p>Если вы знаете, что такое логарифм, то можете пропустить этот раздел. Этот ознакомительный раздел написан для людей, не знакомых с логарифмами; а также для тех, кто давно с ними не сталкивался. Этот текст также предназначен для учеников, которые ещё не изучали логарифмы в школе. Знание логарифмов очень важно, так как они постоянно встречаются при анализе сложности алгоритмов. <em>Логарифм</em> &mdash; это операция, применённая к числу так, что число значительно уменьшается (совсем как извлечение корня). Извлечение квадратного корня является операцией, обратной от возведения числа в квадрат. Точно так же, логарифм &mdash; это обратная операция от возведения числа в какую-либо степень. На самом деле всё гораздо проще, чем звучит. Лучше рассмотрим на таком примере:</p>

        <p>2<sup>x</sup> = 1024</p>

        <p>Для того, чтобы решить это уравнение и найти значение <var>x</var>, мы спрашиваем себя: в какую степень нужно возвести 2, чтобы получить 1024? Это будет число 10. Действительно, мы получаем 2<sup>10</sup> = 1024, что легко подтвердить. Логарифмы помогают записать эту задачку в другой нотации. В данном случае, 10 является логарифмом 1024, что записывается как log( 1024 ) (произносится как &laquo;логарифм 1024&raquo;). Так как мы используем 2 в основании логарифма, то такие логарифмы называются двоичными. Существуют логарифмы и с другими основаниями, но в этой статье мы используем только логарифмы с основанием 2. Если вы ученик, участвующий в международных соревнованиях и не знакомый с логарифмами, то я крайне рекомендую вам <a href='https://tutorial.math.lamar.edu/Classes/Alg/LogFunctions.aspx'>попрактиковаться</a> после прочтения этой статьи. В информатике двоичные логарифмы встречаются гораздо чаще других типов логарифмов. Всё из-за того, что в информатике мы в базе имеем только две сущности: 0 и 1; и предпочитаем разбивать большие проблемы на две части (повторяя это действие). Итак, для дальнейшего чтения статьи вам необходимы только двоичные логарифмы.</p>

        <div class='exercise'>
            <h3>Упражнение 7</h3>

            <p>Решите уравнения. Запишите найденные логарифмы. Используйте только двоичные логарифмы.</p>
            <ol>
                <li>2<sup>x</sup> = 64</li>
                <li>(2<sup>2</sup>)<sup>x</sup> = 64</li>
                <li>4<sup>x</sup> = 4</li>
                <li>2<sup>x</sup> = 1</li>
                <li>2<sup>x</sup> + 2<sup>x</sup> = 32</li>
                <li>(2<sup>x</sup>) * (2<sup>x</sup>) = 64</li>
            </ol>
        </div>

        <div class='exercise solution'>
            <h3>Решения</h3>

            <p>Просто используйте идеи, данные выше.</p>
            <ol>
                <li>Методом проб и ошибок находим, что x = 6 и log( 64 ) = 6.</li>
                <li>Согласно свойствам степеней, (2<sup>2</sup>)<sup>x</sup> можно записать как 2<sup>2x</sup>. Применяя предыдущий результат log( 64 ) = 6, мы получаем, что 2x = 6. Следовательно, x = 3.</li>
                <li>Используя данные из предыдущего уравнения, можно записать 4 в виде 2<sup>2</sup>, так что уравнение преобразуется в (2<sup>2</sup>)<sup>x</sup> = 4, а это то же самое, что 2<sup>2x</sup> = 4. Затем мы замечаем, что log( 4 ) = 2 (ведь 2<sup>2</sup> = 4) и, следовательно, мы получаем, что 2x = 2. Итак, x = 1. Этот результат легко подтвердить, ведь возведение числа в степень 1 возвращает само число.</li>
                <li>Вспомним, что возведение числа в степень 0 даёт в результате 1. Значит, 2<sup>0</sup> = 1, то есть x = 0 и log( 1 ) = 0.</li>
                <li>Здесь мы имеем дело со сложением, так что не можем определить логарифм напрямую. Однако мы замечаем, что 2<sup>x</sup> + 2<sup>x</sup> это то же самое, что и 2 * (2<sup>x</sup>). Итак, у нас появился множитель 2, значит это выражение можно записать в виде 2<sup>x + 1</sup>. Теперь нам осталось только решить уравнение 2<sup>x + 1</sup> = 32. Мы находим, что log( 32 ) = 5 и тогда x + 1 = 5. Следовательно, x = 4.</li>
                <li>Мы умножаем результаты возведения 2 в степень x, значит мы можем объединить множители, заметив, что (2<sup>x</sup>) * (2<sup>x</sup>) равно 2<sup>2x</sup>. Затем всё, что нам надо сделать &mdash; это решить уравнение 2<sup>2x</sup> = 64, которое мы уже решали выше с результатом x = 3.</li>
            </ol>
        </div>

        <div class='highlight'>
            <p class='thumb'><strong>Подсказка</strong>: В случае с алгоритмами, написанными для соревнований (на языке C++), как только сложность была проанализирована, можно получить ориентировочную оценку скорости работы вашей программы. Ожидайте производительность около 1,000,000 операций в секунду (для операций, количество которых определено функцией асимптотического поведения алгоритма). Например, алгоритм со сложностью Θ( n ) отрабатывает приблизительно за секунду при размере входных данных n = 1,000,000.</p>
        </div>

        <div class='right sidefigure'>
            <img src='images/factorial-recursion.png' alt='factorial( 5 ) -&gt; factorial( 4 ) -&gt; factorial( 3 ) -&gt; factorial( 2 ) -&gt; factorial( 1 )' />
            <label><strong>Рисунок 5</strong>: Рекурсия, выполняемая функцией факториала.</label>
        </div>

        <h2 id='recursion'>Сложность рекурсивных алгоритмов</h2>

        <p>Рассмотрим рекурсивные функции. <em>Рекурсивной</em> называется функция, которая вызывает саму себя. Поддаётся ли анализу сложность таких функций? Следующая функция, написанная на языке Python, вычисляет <a href='https://ru.wikipedia.org/wiki/Факториал'>факториал</a> заданного числа. Факториал положительного целого числа находится посредством умножения данного числа с каждым предшествующим ему положительным целым числом. Например, факториал числа 5 равен 5 * 4 * 3 * 2 * 1. Факториал записывается в виде &laquo;5!&raquo;, что произносится как &laquo;пять факториал&raquo; (хотя некоторые люди предпочитают просто громко выкрикивать &laquo;ПЯТЬ!!!&raquo;)</p>

        <div class='leftofimage'>
            <pre class='brush: python; gutter: false; toolbar: false;'>
                def factorial( n ):
                    if n == 1:
                        return 1
                    return n * factorial( n - 1 )
            </pre>
        </div>

        <p>Проанализируем сложность этой функции. Она не содержит циклов, но её сложность всё же не является константной. Для определения сложности нам надо снова заняться подсчётом команд, выполняемых программой. Очевидно, что если передать в эту программу некоторое значение <var>n</var>, то она отработает <var>n</var> раз. Если вы не уверены в этом, то &laquo;вручную&raquo; проверьте как работает функция при n = 5. Вы увидите, что функция будет вызвана 5 раз, каждый раз уменьшая n на 1. Итак, функция имеет сложность Θ( n ).</p>

        <p>Если вы всё ещё не уверены в этом факте, вспомните, что всегда можно найти точную сложность, подсчитав количество выполняемых команд. Если хотите, попробуйте подсчитать реальное количество команд, выполняемых функцией факториала, выведите f( n ) и убедитесь, что она в действительности линейна (напоминаю, что линейная функция соответствует Θ( n )).</p>

        <p><strong>Рисунок 5</strong> содержит диаграмму, которая поможет вам понять, как выглядит рекурсия при вызове функции factorial( 5 ), и почему эта функция имеет линейную сложность.</p>

        <div class='right sidefigure'>
            <img src='images/binary-search.png' alt='Двоичный поиск в массиве' />
            <label><strong>Рисунок 6</strong>: Рекурсия, выполняемая при двоичном (бинарном) поиске. Аргумент A каждого вызова выделен чёрным цветом. Рекурсивные вызовы продолжаются до тех пор, пока в исследуемом массиве не останется один элемент. (Использовано с позволения Luke Francl).</label>
        </div>

        <h2 id='logcomplexity'>Логарифмическая сложность</h2>

        <p>Одна из классических задач в информатике &mdash; это поиск значения в массиве. Мы уже решали такую задачу для общего случая в одном из предыдущих разделов. Поиск в массиве становится очень занимательным, если нам дан уже отсортированный массив. Один из способов поиска в отсортированном массиве называется <em>двоичным (бинарным)</em>. При таком способе проверяется элемент в середине массива: если найдено искомое значение, то поиск закончен; если значение середины больше, чем искомое, то поиск продолжится в левой части массива; иначе поиск продолжится в правой части массива. Затем полученные меньшие массивы снова разбиваются пополам, до тех пор, пока не останется лишь один элемент. Вот этот метод записанный с помощью псевдокода:</p>

        <div class='leftofimage'>
            <pre class='brush: python; gutter: false; toolbar: false;'>
                def binarySearch( A, n, value ):
                    if n = 1:
                        if A[ 0 ] = value:
                            return true
                        else:
                            return false
                    if value &lt; A[ n / 2 ]:
                        return binarySearch( A[ 0...( n / 2 - 1 ) ], n / 2 - 1, value )
                    else if value &gt; A[ n / 2 ]:
                        return binarySearch( A[ ( n / 2 + 1 )...n ], n / 2 - 1, value )
                    else:
                        return true
            </pre>
        </div>

        <p>Этот псевдокод является упрощённой версией реальной реализации двоичного поиска. На практике двоичный поиск легче описать, чем реализовать в коде. Ведь программистам надо позаботиться о всех деталях: <a href="https://ru.wikipedia.org/wiki/Ошибка_на_единицу">ошибках на единицу</a>, необходимости округления результатов деления на 2 и т.д. Учитывая, что мы хотим лишь проанализировать сложность этого алгоритма, то для наших целей предположим, что он всегда работает успешно, и что реальная реализация позаботится о всех необходимых деталях. Если вы никогда не реализовывали двоичный поиск, рекомендую сделать это на вашем любимом языке программирования. Это действительно просвещающее занятие.</p>

        <p><strong>Рисунок 6</strong> должен помочь вам понять, как работает двоичный поиск.</p>

        <p>Если вы не уверены в работоспособности этого метода, возьмите простой пример и убедитесь, что он действительно работает.</p>

        <p>Теперь попробуем проанализировать этот алгоритм. Здесь мы снова столкнулись с рекурсией. Предположим для простоты, что массив всегда делится ровно пополам, и проигнорируем <code>+ 1</code> и <code>- 1</code> в рекурсивных вызовах. К этому моменту вы уже должны понимать, что такое маленькое изменение, как игнорирование <code>+ 1</code> и <code>- 1</code>, не повлияет на результаты анализа сложности. Нам пришлось бы доказывать этот факт, если бы мы хотели быть точными с математической точки зрения, но он и так интуитивно понятен. Также для простоты предположим, что нам дан массив с размером, равным степени 2. Это предположение тоже не повлияет на конечный результат анализа сложности. Наихудший случай этой задачи будет получен, если искомого значения вообще нет в массиве. В такой ситуации, при первом вызове функции, алгоритм получит массив с размером n. При следующем, рекурсивном, вызове: n / 2. Затем рекурсивный вызов получит массив с размером n / 4, за которым последует массив с размером n / 8 и так далее. Массив разбивается пополам при каждом новом рекурсивном вызове, пока не достигнет размера 1. Итак, запишем количество элементов массива при каждом вызове:</p>
        <ol class='hide-nums'>
            <li>0-ой шаг: n</li>
            <li>1-ый шаг: n / 2</li>
            <li>2-ой шаг: n / 4</li>
            <li>3-ий шаг: n / 8</li>
            <li>...</li>
            <li>i-ый</sup> шаг: n / 2<sup>i</sup></li>
            <li>...</li>
            <li>последний шаг: 1</li>
        </ol>

        <p>Обратите внимание, что на i-ом шаге массив имеет n / 2<sup>i</sup> элементов. Так происходит потому, что на каждом шаге массив разделяется пополам (другими словами, мы делим количество элементов массива на 2). Это действие можно выразить в виде умножения знаменателя на 2. При проделывании этой операции i раз, получаем n / 2<sup>i</sup>. Затем процедура деления продолжается, и для всё большего i мы получаем всё меньшее количество элементов, пока не достигнем последнего шага, на котором остаётся лишь 1 элемент. Если мы хотим найти i, чтобы узнать количество шагов работы программы, необходимо решить следующее уравнение:</p>

        <p>1 = n / 2<sup>i</sup></p>

        <p>Это равенство станет верным лишь тогда, когда мы доберёмся до финального вызова функции binarySearch(), а не в общем случае. Найдя i, мы найдём, на каком шаге закончатся рекурсивные вызовы. Умножив обе стороны на 2<sup>i</sup>, получаем:</p>

        <p>2<sup>i</sup> = n</p>

        <p>Это уравнение должно выглядеть знакомым, если вы прочитали раздел о логарифмах. Решив уравнение для i, получаем:</p>

        <p>i = log( n )</p>

        <p>Это выражение говорит нам, что количество шагов, необходимое для осуществления двоичного поиска, равно log( n ), где n &mdash; количество элементов в данном массиве.</p>

        <p>Такой результат выглядит вполне реалистично. Например, возьмите n = 32, массив с 32 элементами. Сколько раз нам придётся делить массив пополам, чтобы получить 1 элемент? Мы получим: 32 → 16 → 8 → 4 → 2 → 1 элементов, проделав 5 шагов, что и есть логарифм 32. Следовательно, сложность двоичного поиска равна Θ( log( n ) ).</p>

        <p>Последний результат позволяет нам сравнить двоичный поиск с линейным поиском (предыдущий из рассмотренных нами методов). Очевидно, что log( n ) гораздо меньше n, так что мы заключаем, что двоичный поиск ищет элементы в массиве гораздо быстрее, чем линейный поиск. Также можно порекомендовать поддерживать массивы отсортированными, если необходимо часто осуществлять поиск по ним.</p>

        <div class='highlight'>
            <p class='thumb'><strong>Подсказка</strong>: Улучшение асимптотического времени работы программ также часто значительно улучшает их время работы. И в гораздо больших масштабах, чем любые мелкие &laquo;технические&raquo; оптимизации, как, например, использование более быстрого языка программирования.</p>
        </div>

        <h2 id='sort'>Оптимальная сортировка</h2>

        <p><strong>Поздравляю.</strong> Теперь вы знаете, что такое анализ сложности алгоритмов, асимптотическое поведение и &laquo;О&dash;большое&raquo;. Теперь вы знаете, что такое сложность алгоритма O( 1 ), O( log( n ) ), O( n ), O( n<sup>2</sup> ) и так далее. Вы понимаете значение символов o, O, ω, Ω и Θ, и что такое анализ наихудшего случая. Раз вы добрались до этого этапа, значит учебный материал справился со своей задачей.</p>

        <p>Этот финальный раздел необязателен для прочтения. Он более сложный, так что можете опустить его, если почувствуете, что вы перегружены. Этот раздел потребует от вас фокусировки для проработки дополнительных упражнений. При этом, он покажет вам очень полезный и потенциально мощный метод анализа сложности алгоритмов, что может стать ст<strong>о</strong>ящим вложением сил.</p>

        <p>Выше мы рассматривали реализацию алгоритма под названием сортировка выбором. Было упомянуто, что сортировка выбором &mdash; это не оптимальный алгоритм. <em>Оптимальным</em> называется алгоритм, который решает задачу самым лучшим способом. Это означает, что все другие алгоритмы решения этой же задачи имеют сложность худшую или такую же, как у оптимального алгоритма. Для решения задач определённой сложности существует множество оптимальных алгоритмов. В частности, задача сортировки может быть решена оптимально разными способами. Например, мы можем использовать ту же идею, что лежит в основе двоичного поиска, чтобы получить быстрый способ сортировки, который называется <em>сортировка слиянием</em> (англ. merge sort).</p>

        <p>Чтобы выполнить сортировку слиянием, сначала необходимо написать вспомогательную функцию, которая будет использована во время самой сортировки. Мы создадим функцию <code>merge</code>. Эта функция принимает два отсортированных массива и соединяет (англ. merge: слияние) их вместе, в один упорядоченный массив. Это легко сделать:</p>

        <pre class='brush: python; gutter: false; toolbar: false;'>
            def merge( A, B ):
                if empty( A ):
                    return B
                if empty( B ):
                    return A
                if A[ 0 ] &lt; B[ 0 ]:
                    return concat( A[ 0 ], merge( A[ 1...A_n ], B ) )
                else:
                    return concat( B[ 0 ], merge( A, B[ 1...B_n ] ) )
        </pre>

        <p>Функция concat принимает элемент (&laquo;голову&raquo;) и массив (&laquo;хвост&raquo;), затем строит и возвращает новый массив, содержащий данную &laquo;голову&raquo; на первой позиции нового массива и элементы данного &laquo;хвоста&raquo; на остальных позициях массива. Например, concat( 3, [ 4, 5, 6 ] ) возвращает [ 3, 4, 5, 6 ]. Мы используем  A_n и B_n для обозначения размеров массива A и B, соответственно.</p>

        <div class='exercise'>
            <h3>Упражнение 8</h3>

            <p>Проверьте, что данная выше функция действительно выполняет слияние. Перепишите её на своём любимом языке программирования, используя цикл <code>for</code> вместо рекурсии.</p>
        </div>

        <p>Анализ этого алгоритма показывает, что время его выполнения Θ( n ), где n размер конечного массива (n = A_n + B_n).</p>

        <div class='exercise'>
            <h3>Упражнение 9</h3>

            <p>Подтвердите, что время работы функции <code>merge</code> соответствует Θ( n ).</p>
        </div>

        <p>Используя эту функцию, можно построить улучшенный алгоритм сортировки. Базовая идея: делить массив на две части. Мы сортируем каждую из двух частей рекурсивно, а затем объединяем два отсортированных массива в один большой массив. Псевдокод:</p>

        <pre class='brush: python; gutter: false; toolbar: false;'>
        def mergeSort( A, n ):
            if n = 1:
                return A # он уже отсортирован
            middle = floor( n / 2 )
            leftHalf = A[ 1...middle ]
            rightHalf = A[ ( middle + 1 )...n ]
            return merge( mergeSort( leftHalf, middle ), mergeSort( rightHalf, n - middle ) )
        </pre>

        <p>Эту функцию сложнее понять, чем то, что мы уже рассматривали, так что следующее упражнение может потребовать от вас больше времени.</p>

        <div class='exercise'>
            <h3>Упражнение 10</h3>

            <p>Подтвердите, что функция <code>mergeSort</code> работает верно. А именно, что она действительно сортирует данный ей массив. Если вы не понимаете, как эта функция работает, то возьмите маленький массив и отследите &laquo;вручную&raquo; шаги, выполняемые <code>mergeSort</code>. При этом вы убедитесь, что leftHalf и rightHalf образуются при разбиении массива <i>приблизительно</i> посередине; разбиение не обязательно происходит точно в центре массива, если он содержит нечётное количество элементов (по этой причине используется функция <code>floor</code>).</p>
        </div>

        <p>В качестве последнего примера, подвергнем анализу сложность <code>mergeSort</code>. На каждом этапе выполнения <code>mergeSort</code>, массив разбивается на две части одинакового размера, совсем как в <code>binarySearch</code>. Однако в случае сортировки обе части сохраняются в процессе выполнения программы. Алгоритм применяется рекурсивно к каждой из частей. К результату выполнения рекурсий применяется операция <code>merge</code>, которая занимает Θ( n ) времени.</p>

        <p>Итак, мы разбиваем данный массив на два массива, каждый с размером n / 2. Затем мы объединяем эти новые массивы, и это действие объединения <var>n</var> элементов требует Θ( n ) времени.</p>

        <p>Взгляните на <strong>Рисунок 7</strong>, чтобы лучше понять происходящее.</p>

        <div class='sidefigure'>
            <img src='images/mergesort-recursion.png' alt='N разбивается на N / 2 и N / 2, каждый из которых разбивается на N / 4 и  N / 4. Этот процесс продолжается до получения размера в один элемент.' />
            <label><strong>Рисунок 7</strong>: Дерево рекурсии для сортировки слиянием.</label>
        </div>

        <p>Посмотрим, что здесь происходит. Каждый круг отображает вызов функции <code>mergeSort</code>. Число внутри круга показывает размер сортируемого массива. Верхний синий круг &mdash; это изначальный вызов <code>mergeSort</code>, с задачей отсортировать массив размера <var>n</var>. Стрелки показывают рекурсивные вызовы функции. Изначальный вызов <code>mergeSort</code> делает два рекурсивных запроса к <code>mergeSort</code>, передавая каждый раз один массив с размером n / 2. Это действие отображается двумя стрелками вверху картинки. В свою очередь, каждый из вызовов функции делает ещё два вызова <code>mergeSort</code>, передавая каждый раз массив с размером n / 4 и так далее, пока не будут получены массивы с одним элементом. Такая схема называется <em>рекурсивным деревом</em>, потому что она отображает последовательность рекурсивных вызовов и похожа на дерево (точнее на перевёрнутое дерево, <em>корень</em> которого расположен вверху, а <em>листья</em> &mdash; внизу).</p>

        <p>Обратите внимание, что в каждом ряду схемы общее количество элементов всегда равно n. Чтобы увидеть это, рассмотрите каждый ряд по отдельности. Первый ряд содержит только один вызов <code>mergeSort</code> с массивом размера <var>n</var>, так что общее количество элементов равно <var>n</var>. Второй ряд содержит два вызова <code>mergeSort</code>, где каждый из массивов имеет размер n / 2. Но n / 2 + n / 2 = n, так что снова общее количество элементов в этом ряду равно <var>n</var>. В третьем ряду мы видим 4 вызова, каждый из которых обрабатывает массив с размером n / 4, в результате давая общее количество элементов равное n / 4 + n / 4 + n / 4 + n / 4 = 4n / 4 = n. Итак, снова мы получаем <var>n</var> элементов. Теперь обратите внимание на то, что в каждом ряду схемы вызывающая функция должна будет выполнить операцию <code>merge</code> с элементами, возвращаемыми вызываемыми функциями. Например, круг, обозначенный красным цветом, должен отсортировать n / 2 элементов. Чтобы сделать это, он разбивает массив с размером n / 2 на два массива с размером n / 4, вызывает рекурсивно <code>mergeSort</code> для их сортировки (эти вызовы отображены кругами зелёного цвета), затем объединяет результаты в один массив. Операция объединения работает с n / 2 элементами. В каждом ряду нашего дерева общее количество объединяемых элементов равно n. В только что рассмотренном ряду функция объединяет n / 2 элементов; функция справа от неё (показана синим цветом) тоже объединяет n / 2 элементов. Итого получаем n объединяемых элементов в рассматриваемом ряду схемы.</p>

        <p>В соответствии с этим рассуждением, каждый ряд имеет сложность Θ( n ). Нам известно, что количество рядов &mdash; известное под названием <em>глубина</em> дерева рекурсии &mdash; в данной схеме равно log( n ). Выводится это так же, как было сделано во время анализа сложности двоичного поиска. При количестве рядов log( n ), с каждым из них имеющим сложность Θ( n ), сложность <code>mergeSort</code> равна Θ( n * log( n ) ). Это гораздо лучший результат, чем Θ( n<sup>2</sup> ), получаемый при использовании сортировки выбором (напоминаю, что log( n ) гораздо меньше n, так что n * log( n ) гораздо меньше n * n = n<sup>2</sup>). Если всё это звучит слишком сложно для вас, не беспокойтесь: такую информацию непросто понять с первого раза; прочитайте этот раздел ещё раз после того, как вы сами попробуете реализовать сортировку слиянием и убедитесь, что она работает.</p>

        <p>Как было показано в последнем примере, анализ сложности позволяет нам сравнивать алгоритмы между собой для выяснения, какой из них работает лучше. Теперь мы вполне уверены, что для больших массивов данных сортировка слиянием работает быстрее, чем сортировка выбором. Прийти к этому выводу было бы тяжело без теоретических знаний, представленных в этой статье и необходимых для анализа алгоритмов. На практике действительно используют алгоритмы сортировки со временем работы Θ( n * log( n ) ). Например, <a href='https://github.com/torvalds/linux/blob/master/lib/sort.c'>ядро Linux использует алгоритм под названием пирамидальная сортировка (англ. heapsort)</a>, с тем же временем работы, что и у сортировки слиянием, рассмотренной нами  &mdash; а именно Θ( n log( n ) ) &mdash; и являющимся оптимальным алгоритмом. Обратите внимание: мы не доказывали, что эти алгоритмы оптимальны. Для этого нам понадобилась бы более сложная математическая аргументация. Однако могу вас уверить, что с точки зрения сложности алгоритмов, сортировку нельзя сделать более эффективной.</p>

        <p>Те знания об анализе сложности алгоритмов, которые вы приобрели во время чтения этой статьи, должны помочь вам создавать более быстрые программы и фокусировать усилия, прикладываемые для оптимизации кода, на действительно значимых вещах; таким образом делая вас более продуктивным. Также, математический язык и обозначения, с которыми вы познакомились, читая эту статью, помогут вам при общении с другими программистами. Теперь вы сможете обсуждать время работы алгоритмов, используя полученные знания.</p>

        <h2 id='about'>Заключение</h2>
        <p>Эта статья лицензируется с <a href='https://creativecommons.org/licenses/by/3.0/deed.ru'>Creative Commons 3.0 Attribution</a>. Это означает, что статью можно копировать, распространять, публиковать на вашем ресурсе, изменять, в общем делать с ней всё, что хотите &mdash; при этом указав моё имя. Если вы основываете свою работу на моей статье, вы не обязаны, но я вам предлагаю тоже опубликовать ваш текст с лицензией Creative Commons, так как и другим людям будет проще делиться и сотрудничать. В соответствии с этим подходом, я упомяну работы, которые я использовал: <a href='http://p.yusukekamiyamane.com/'>fugue icons</a>, <a href='http://leaverou.me/css3patterns/'>Lea Verou</a>. И, самое важное, я смог написать эту статью благодаря знаниям, полученным от профессоров <a href='http://www.softlab.ntua.gr/~nickie/'>Nikos Papaspyrou</a> и <a href='http://www.softlab.ntua.gr/~fotakis/'>Dimitris Fotakis</a>.</p>

        <p>Я являюсь PhD кандидатом в области криптографии в <a href='http://di.uoa.gr'>Афинском университете</a>. Когда я писал эту статью, я был студентом факультета <a href='http://ece.ntua.gr/'>Электротехники и компьютерных наук</a> <a href='http://ntua.gr/'>Афинского национального технического университета</a>, специализируясь в <a href='http://www.cslab.ntua.gr'>программном обеспечении</a> и будучи тренером по <a href='http://pdp.gr/'>Греческим соревнованиям в области информатики</a>. Как программист практик, я был в команде, построившей <a href='http://www.deviantart.com/'>deviantART</a>, социальную сеть для художников; в командах безопасности в <a href='https://www.google.com'>Google</a> и <a href='https://twitter.com'>Twitter</a>; а также в стартапах Zino и Kamibu, которые занимались социальными сетями и разработкой видеоигр, соответственно. Если вам понравилась статья, подписывайтесь в <a href='http://www.twitter.com/dionyziz'>Twitter</a> или <a href='http://github.com/dionyziz'>GitHub</a>. <a href='mailto:dionyziz@gmail.com'>Отправьте e-mail</a>, если хотите связаться со мной или заняться переводом данного текста.</p>

        <p><strong>Благодарю вас за чтение.</strong> Мне не оплачивали написание этой статьи, так что если вам она понравилась, <a href='mailto:dionyziz@gmail.com'>отправьте мне e-mail</a> с приветствием. Мне нравится получать фотографии со всего мира. Если захотите, присылайте ваше фото в городе, где вы живёте!</p>

        <h2 id='references'>Ресурсы</h2>
        <ol>
            <li>Cormen, Leiserson, Rivest, Stein. <a href='http://www.amazon.co.uk/Introduction-Algorithms-T-Cormen/dp/0262533057/ref=sr_1_1?ie=UTF8&amp;qid=1341414466&amp;sr=8-1'>Introduction to Algorithms</a>, MIT Press.</li>
            <li>Dasgupta, Papadimitriou, Vazirani. <a href='http://www.amazon.co.uk/Algorithms-Sanjoy-Dasgupta/dp/0073523402/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1341414505&amp;sr=1-1'>Algorithms</a>, McGraw-Hill Press.</li>
            <li>Fotakis. Course of <a href='http://discrete.gr/'>Discrete Mathematics</a> at the National Technical University of Athens.</li>
            <li>Fotakis. Course of <a href='http://www.corelab.ece.ntua.gr/courses/algorithms/'>Algorithms and Complexity</a> at the National Technical University of Athens.</li>
        </ol>

       <div id="disqus_thread"></div>
<?php
    return array(
        'title' => 'Доступное введение в анализ сложности алгоритмов.',
        'content' => ob_get_clean()
    );
?>
